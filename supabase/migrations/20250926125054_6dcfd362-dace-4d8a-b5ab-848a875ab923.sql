-- Adicionar campos de versionamento à tabela proposals
ALTER TABLE public.proposals 
ADD COLUMN current_version INTEGER DEFAULT 1,
ADD COLUMN version_count INTEGER DEFAULT 1;

-- Criar tabela para armazenar histórico de versões
CREATE TABLE public.proposal_versions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  proposal_id BIGINT NOT NULL REFERENCES public.proposals(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  title TEXT NOT NULL,
  value NUMERIC,
  status TEXT,
  pdf_url TEXT,
  change_description TEXT,
  changed_by UUID REFERENCES auth.users(id),
  is_current BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(proposal_id, version_number)
);

-- Habilitar RLS na tabela proposal_versions
ALTER TABLE public.proposal_versions ENABLE ROW LEVEL SECURITY;

-- Políticas RLS para proposal_versions (mesmas regras das propostas)
CREATE POLICY "SELECT: Dono da proposta, Dono da empresa, Dono do projeto ou Admin" 
ON public.proposal_versions 
FOR SELECT 
USING (
  (SELECT users.role FROM users WHERE users.id = auth.uid()) = 'admin'::text
  OR 
  proposal_id IN (
    SELECT p.id FROM proposals p 
    WHERE p.owner_id = auth.uid() 
    OR p.company_id IN (SELECT c.id FROM companies c WHERE c.owner_id = auth.uid())
    OR p.project_id IN (SELECT pr.id FROM projects pr WHERE pr.manager_id = auth.uid())
  )
);

CREATE POLICY "INSERT: Apenas sistema pode criar versões" 
ON public.proposal_versions 
FOR INSERT 
WITH CHECK (changed_by = auth.uid());

-- Função para criar uma nova versão quando proposta é atualizada
CREATE OR REPLACE FUNCTION public.create_proposal_version()
RETURNS TRIGGER AS $$
BEGIN
  -- Se algum campo relevante mudou, criar nova versão
  IF OLD.title IS DISTINCT FROM NEW.title OR 
     OLD.value IS DISTINCT FROM NEW.value OR 
     OLD.status IS DISTINCT FROM NEW.status OR 
     OLD.pdf_url IS DISTINCT FROM NEW.pdf_url THEN
    
    -- Marcar versão anterior como não atual
    UPDATE public.proposal_versions 
    SET is_current = false 
    WHERE proposal_id = NEW.id;
    
    -- Incrementar contadores de versão
    NEW.current_version = COALESCE(OLD.current_version, 1) + 1;
    NEW.version_count = COALESCE(OLD.version_count, 1) + 1;
    
    -- Inserir nova versão no histórico
    INSERT INTO public.proposal_versions (
      proposal_id,
      version_number,
      title,
      value,
      status,
      pdf_url,
      change_description,
      changed_by,
      is_current
    ) VALUES (
      NEW.id,
      NEW.current_version,
      NEW.title,
      NEW.value,
      NEW.status,
      NEW.pdf_url,
      CASE 
        WHEN OLD.title IS DISTINCT FROM NEW.title THEN 'Título alterado'
        WHEN OLD.value IS DISTINCT FROM NEW.value THEN 'Valor alterado'
        WHEN OLD.status IS DISTINCT FROM NEW.status THEN 'Status alterado'
        WHEN OLD.pdf_url IS DISTINCT FROM NEW.pdf_url THEN 'PDF atualizado'
        ELSE 'Proposta atualizada'
      END,
      auth.uid(),
      true
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger para criar versões automaticamente
CREATE TRIGGER proposal_versioning_trigger
  BEFORE UPDATE ON public.proposals
  FOR EACH ROW
  EXECUTE FUNCTION public.create_proposal_version();

-- Função para criar versão inicial para propostas existentes
CREATE OR REPLACE FUNCTION public.initialize_proposal_versions()
RETURNS void AS $$
DECLARE
  prop RECORD;
BEGIN
  FOR prop IN SELECT * FROM public.proposals LOOP
    INSERT INTO public.proposal_versions (
      proposal_id,
      version_number,
      title,
      value,
      status,
      pdf_url,
      change_description,
      changed_by,
      is_current
    ) VALUES (
      prop.id,
      1,
      prop.title,
      prop.value,
      prop.status,
      prop.pdf_url,
      'Versão inicial',
      prop.owner_id,
      true
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Executar inicialização para propostas existentes
SELECT public.initialize_proposal_versions();